

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>NIPAP API &mdash; NIPAP v1.0 documentation</title>
    <link rel="stylesheet" href="static/default.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <link rel="top" title="NIPAP v1.0 documentation" href="index.html" />
    <link rel="next" title="XML-RPC glue class" href="xmlrpc.html" />
    <link rel="prev" title="Design choices" href="design.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="xmlrpc.html" title="XML-RPC glue class"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="design.html" title="Design choices"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">NIPAP v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-nipap.nipap"></span><div class="section" id="nipap-api">
<h1>NIPAP API<a class="headerlink" href="#nipap-api" title="Permalink to this headline">¶</a></h1>
<p>This module contains the Nipap class which provides most of the logic in NIPAP
apart from that contained within the PostgreSQL database.</p>
<p>NIPAP contains three types of objects: schemas, prefixes and pools.</p>
<div class="section" id="schema">
<h2>Schema<a class="headerlink" href="#schema" title="Permalink to this headline">¶</a></h2>
<p>A schema can be thought of as a namespace for IP addresses, they make it
possible to keep track of addresses that are used simultaneously in multiple
parallell routing tables / VRFs. A typical example would be customer VPNs,
where multiple customers are using the same RFC1918 addresses.  By far, most
operations will be carried out in the &#8216;global&#8217; schema which contains addresses
used on the Internet. Most API functions require a schema to be passed as
the first argument.</p>
<div class="section" id="schema-attributes">
<h3>Schema attributes<a class="headerlink" href="#schema-attributes" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">id</span></tt> - ID number of the schema.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt> - A short name, such as &#8216;global&#8217;.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">description</span></tt> - A longer description of what the schema is used for.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">vrf</span></tt> - The VRF where the addresses in the schema is used.</li>
</ul>
</div>
<div class="section" id="schema-functions">
<h3>Schema functions<a class="headerlink" href="#schema-functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference internal" href="#nipap.nipap.Nipap.list_schema" title="nipap.nipap.Nipap.list_schema"><tt class="xref py py-func docutils literal"><span class="pre">list_schema()</span></tt></a> - Return a list of schemas.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.add_schema" title="nipap.nipap.Nipap.add_schema"><tt class="xref py py-func docutils literal"><span class="pre">add_schema()</span></tt></a> - Create a new schema.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.edit_schema" title="nipap.nipap.Nipap.edit_schema"><tt class="xref py py-func docutils literal"><span class="pre">edit_schema()</span></tt></a> - Edit a schema.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.remove_schema" title="nipap.nipap.Nipap.remove_schema"><tt class="xref py py-func docutils literal"><span class="pre">remove_schema()</span></tt></a> - Remove a schema.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.search_schema" title="nipap.nipap.Nipap.search_schema"><tt class="xref py py-func docutils literal"><span class="pre">search_schema()</span></tt></a> - Search schemas from a specifically formatted dict.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.smart_search_schema" title="nipap.nipap.Nipap.smart_search_schema"><tt class="xref py py-func docutils literal"><span class="pre">smart_search_schema()</span></tt></a> - Search schemas from arbitarly formatted string.</li>
</ul>
</div>
</div>
<div class="section" id="prefix">
<h2>Prefix<a class="headerlink" href="#prefix" title="Permalink to this headline">¶</a></h2>
<p>A prefix object defines an address prefix. Prefixes can be one of three
different types; reservation, assignment or host.
Reservation; a prefix which is reserved for future use.
Assignment; addresses assigned to a specific purpose.
Host; prefix of max length within an assigment, assigned to an end host.</p>
<div class="section" id="prefix-attributes">
<h3>Prefix attributes<a class="headerlink" href="#prefix-attributes" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">id</span></tt> - ID number of the prefix.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">prefix</span></tt> - The IP prefix itself.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">display_prefix</span></tt> - A more user-friendly version of the prefix.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">family</span></tt> - Address family (integer 4 or 6). Set by NIPAP.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">schema</span></tt> - ID number of the schema the prefix belongs to.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">description</span></tt> - A short description of the prefix.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">comment</span></tt> - A longer text describing the prefix and its use.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">node</span></tt> - FQDN of node the prefix is assigned to, if type is host.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">pool</span></tt> - ID of pool, if the prefix belongs to a pool.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">type</span></tt> - Prefix type, string &#8216;reservation&#8217;, &#8216;assignment&#8217; or &#8216;host&#8217;.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">indent</span></tt> - Depth in prefix tree. Set by NIPAP.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">country</span></tt> - Country where the prefix resides (two-letter country code).</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">order_id</span></tt> - Order identifier.</p>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">external_key</span></tt> - A field for use by external systems which needs to</dt>
<dd><p class="first last">store references to its own dataset.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">authoritative_source</span></tt> - String identifying which system last</dt>
<dd><p class="first last">modified the prefix.</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">alarm_priority</span></tt> - String &#8216;low&#8217;, &#8216;medium&#8217; or &#8216;high&#8217;. Used by netwatch.</p>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">monitor</span></tt> - A boolean specifying whether the prefix should be</dt>
<dd><p class="first last">monitored or not.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">display</span></tt> - Only set by the <a class="reference internal" href="#nipap.nipap.Nipap.search_prefix" title="nipap.nipap.Nipap.search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">search_prefix()</span></tt></a> and</dt>
<dd><p class="first last"><a class="reference internal" href="#nipap.nipap.Nipap.smart_search_prefix" title="nipap.nipap.Nipap.smart_search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">smart_search_prefix()</span></tt></a> functions, see their documentation for
explanation.</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="prefix-functions">
<h3>Prefix functions<a class="headerlink" href="#prefix-functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference internal" href="#nipap.nipap.Nipap.list_prefix" title="nipap.nipap.Nipap.list_prefix"><tt class="xref py py-func docutils literal"><span class="pre">list_prefix()</span></tt></a> - Return a list of prefixes.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.add_prefix" title="nipap.nipap.Nipap.add_prefix"><tt class="xref py py-func docutils literal"><span class="pre">add_prefix()</span></tt></a> - Add a prefix. The prefix itself can be selected by Nipap.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.edit_prefix" title="nipap.nipap.Nipap.edit_prefix"><tt class="xref py py-func docutils literal"><span class="pre">edit_prefix()</span></tt></a> - Edit a prefix.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.remove_prefix" title="nipap.nipap.Nipap.remove_prefix"><tt class="xref py py-func docutils literal"><span class="pre">remove_prefix()</span></tt></a> - Remove a prefix.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.search_prefix" title="nipap.nipap.Nipap.search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">search_prefix()</span></tt></a> - Search prefixes from a specifically formatted dict.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.smart_search_prefix" title="nipap.nipap.Nipap.smart_search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">smart_search_prefix()</span></tt></a> - Search prefixes from arbitarly formatted string.</li>
</ul>
</div>
</div>
<div class="section" id="pool">
<h2>Pool<a class="headerlink" href="#pool" title="Permalink to this headline">¶</a></h2>
<p>Reserved prefixes can be gathered in a pool which then can be used when
adding prefixes. The <cite>add_prefix</cite> can for example be asked to return a
prefix from the pool CORE-LOOPBACKS. Then all the prefix member of this pool
will be examined for a suitable prefix with the default length specified in
the pool if nothing else is given.</p>
<div class="section" id="pool-attributes">
<h3>Pool attributes<a class="headerlink" href="#pool-attributes" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">id</span></tt> - ID number of the pool.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt> - A short name.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">description</span></tt> - A longer description of the pool.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">schema</span></tt> - ID number of the schema is it associated with.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">default_type</span></tt> - Default prefix type (see prefix types above.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">ipv4_default_prefix_length</span></tt> - Default prefix length of IPv4 prefixes.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">ipv6_default_prefix_length</span></tt> - Default prefix length of IPv6 prefixes.</li>
</ul>
</div>
<div class="section" id="pool-functions">
<h3>Pool functions<a class="headerlink" href="#pool-functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference internal" href="#nipap.nipap.Nipap.list_pool" title="nipap.nipap.Nipap.list_pool"><tt class="xref py py-func docutils literal"><span class="pre">list_pool()</span></tt></a> - Return a list of pools.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.add_pool" title="nipap.nipap.Nipap.add_pool"><tt class="xref py py-func docutils literal"><span class="pre">add_pool()</span></tt></a> - Add a pool.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.edit_pool" title="nipap.nipap.Nipap.edit_pool"><tt class="xref py py-func docutils literal"><span class="pre">edit_pool()</span></tt></a> - Edit a pool.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.remove_pool" title="nipap.nipap.Nipap.remove_pool"><tt class="xref py py-func docutils literal"><span class="pre">remove_pool()</span></tt></a> - Remove a pool.</li>
</ul>
</div>
</div>
<div class="section" id="the-spec">
<h2>The &#8216;spec&#8217;<a class="headerlink" href="#the-spec" title="Permalink to this headline">¶</a></h2>
<p>Central to the use of the NIPAP API is the spec &#8211; the specifier. It is used
by many functions to in a more dynamic way specify what element(s) you want
to select. Mainly it came to be due to the use of two attributes which can
be thought of as primary keys for an object, such as a pool&#8217;s <tt class="xref py py-attr docutils literal"><span class="pre">id</span></tt> and
<tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt> attribute. They are however implemented so that you can use
more or less any attribute in the spec, to be able to for example get all
prefixes of family 6 with type reservation.</p>
<p>The spec is a dict formatted as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">schema_spec</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;id&#39;</span><span class="p">:</span> <span class="mi">512</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But can also be elaborated somehwat for certain objects, as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prefix_spec</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;family&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
    <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="s">&#39;reservation&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If multiple keys are given, they will be ANDed together.</p>
</div>
<div class="section" id="authorization-accounting">
<h2>Authorization &amp; accounting<a class="headerlink" href="#authorization-accounting" title="Permalink to this headline">¶</a></h2>
<p>With each query an object extending the BaseAuth class should be passed.
This object is used in the Nipap class to perform authorization (not yet
implemented) and accounting. Authentication should be performed at an
earlier stage and is NOT done in the Nipap class.</p>
<p>Each command which alters data stored in NIPAP is logged. There are
currently no API functions for extracting this data, but this will change
in the future.</p>
</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nipap.nipap.Inet">
<em class="property">class </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">Inet</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Inet" title="Permalink to this definition">¶</a></dt>
<dd><p>This works around a bug in psycopg2 version somewhere before 2.4.  The
__init__ function in the original class is broken and so this is merely
a copy with the bug fixed.</p>
<p>Wrap a string to allow for correct SQL-quoting of inet values.</p>
<p>Note that this adapter does NOT check the passed value to make sure it
really is an inet-compatible address but DOES call adapt() on it to make
sure it is impossible to execute an SQL-injection by passing an evil
value to the initializer.</p>
</dd></dl>

<dl class="class">
<dt id="nipap.nipap.Nipap">
<em class="property">class </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">Nipap</tt><a class="headerlink" href="#nipap.nipap.Nipap" title="Permalink to this definition">¶</a></dt>
<dd><p>Main NIPAP class.</p>
<p>The main NIPAP class containing all API methods. When creating an
instance, a database connection object is created which is used during
the instance&#8217;s lifetime.</p>
<dl class="method">
<dt id="nipap.nipap.Nipap.add_pool">
<tt class="descname">add_pool</tt><big>(</big><em>auth</em>, <em>schema_spec</em>, <em>attr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.add_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a pool according to <cite>attr</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>schema_spec</cite> [schema_spec]</dt>
<dd><p class="first last">Specifies what schema we are working within.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attr</cite> [pool_attr]</dt>
<dd><p class="first last">A dict containing the attributes the new pool should have.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns ID of the added pool.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.add_prefix">
<tt class="descname">add_prefix</tt><big>(</big><em>auth</em>, <em>schema_spec</em>, <em>attr</em>, <em>args={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.add_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a prefix and return its ID.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>schema_spec</cite> [schema_spec]</dt>
<dd><p class="first last">Specifies what schema we are working within.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attr</cite> [prefix_attr]</dt>
<dd><p class="first last">Prefix attributes.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>args</cite> [add_prefix_args]</dt>
<dd><p class="first last">Arguments explaining how the prefix should be allocated.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns ID of the added prefix.</p>
<p>Prefixes can be added in three ways; manually, from a pool or
from a prefix.</p>
<dl class="docutils">
<dt>Manually</dt>
<dd>All prefix data, including the prefix itself is specified in the
<cite>attr</cite> argument. The <cite>args</cite> argument shall be omitted.</dd>
<dt>From a pool</dt>
<dd>Most prefixes are expected to be automatically assigned from a pool.
In this case, the <tt class="xref py py-attr docutils literal"><span class="pre">prefix</span></tt> key is omitted from the <cite>attr</cite> argument.
Also the <tt class="xref py py-attr docutils literal"><span class="pre">type</span></tt> key can be omitted and the prefix type will then be
set to the pools default prefix type. The <a class="reference internal" href="#nipap.nipap.Nipap.find_free_prefix" title="nipap.nipap.Nipap.find_free_prefix"><tt class="xref py py-func docutils literal"><span class="pre">find_free_prefix()</span></tt></a>
function is used to find available prefixes for this allocation
method, see its documentation for a description of how the
<cite>args</cite> argument should be formatted.</dd>
<dt>From a prefix</dt>
<dd>A prefix can also be selected from another prefix. Also in this case
the <tt class="xref py py-attr docutils literal"><span class="pre">prefix</span></tt> key is omitted from the <cite>attr</cite> argument. See the
documentation for the <a class="reference internal" href="#nipap.nipap.Nipap.find_free_prefix" title="nipap.nipap.Nipap.find_free_prefix"><tt class="xref py py-func docutils literal"><span class="pre">find_free_prefix()</span></tt></a> for a description of how
the <cite>args</cite> argument is to be formatted.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.add_schema">
<tt class="descname">add_schema</tt><big>(</big><em>auth</em>, <em>attr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.add_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new network schema.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attr</cite> [schema_attr]</dt>
<dd><p class="first last">The news schema&#8217;s attributes.</p>
</dd>
</dl>
</li>
</ul>
<p>Add a schema based on the values stored in the inputted attr dict.</p>
<p>Returns the ID of the added schema.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.edit_pool">
<tt class="descname">edit_pool</tt><big>(</big><em>auth</em>, <em>schema_spec</em>, <em>spec</em>, <em>attr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.edit_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Update pool given by <cite>spec</cite> with attributes <cite>attr</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>schema_spec</cite> [schema_spec]</dt>
<dd><p class="first last">Specifies what schema we are working within.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [pool_spec]</dt>
<dd><p class="first last">Specifies what pool to edit.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attr</cite> [pool_attr]</dt>
<dd><p class="first last">Attributes to update and their new values.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.edit_prefix">
<tt class="descname">edit_prefix</tt><big>(</big><em>auth</em>, <em>schema_spec</em>, <em>spec</em>, <em>attr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.edit_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Update prefix matching <cite>spec</cite> with attributes <cite>attr</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>schema_spec</cite> [schema_spec]</dt>
<dd><p class="first last">Specifies what schema we are working within.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [prefix_spec]</dt>
<dd><p class="first last">Specifies the prefix to edit.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attr</cite> [prefix_attr]</dt>
<dd><p class="first last">Prefix attributes.</p>
</dd>
</dl>
</li>
</ul>
<p>Note that a prefix&#8217;s type or schema can not be changed.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.edit_schema">
<tt class="descname">edit_schema</tt><big>(</big><em>auth</em>, <em>spec</em>, <em>attr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.edit_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Updata schema matching <cite>spec</cite> with attributes <cite>attr</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [schema_spec]</dt>
<dd><p class="first last">Schema specification.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attr</cite> [schema_attr]</dt>
<dd><p class="first last">Dict specifying fields to be updated and their new values.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.find_free_prefix">
<tt class="descname">find_free_prefix</tt><big>(</big><em>auth</em>, <em>schema_spec</em>, <em>args</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.find_free_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds free prefixes in the sources given in <cite>args</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>schema_spec</cite> [schema_spec]</dt>
<dd><p class="first last">Specifies what schema we are working within.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>args</cite> [find_free_prefix_args]</dt>
<dd><p class="first last">Arguments to the find free prefix function.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
<p>Prefixes can be found in two ways: from a pool of from a prefix.</p>
<p>From a pool
The <cite>args</cite> argument is set to a dict with key <tt class="xref py py-attr docutils literal"><span class="pre">from-pool</span></tt> set to a
pool spec. This is the pool from which the prefix will be assigned.
Also the key <tt class="xref py py-attr docutils literal"><span class="pre">family</span></tt> needs to be set to the adress family (integer
4 or 6) of the requested prefix.  Optionally, also the key
<tt class="xref py py-attr docutils literal"><span class="pre">prefix_length</span></tt> can be added to the <cite>attr</cite> argument, and will then
override the default prefix length.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;from-pool&#39;</span><span class="p">:</span> <span class="p">{</span> <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;CUSTOMER-&#39;</span> <span class="p">},</span>
    <span class="s">&#39;family&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
    <span class="s">&#39;prefix_length&#39;</span><span class="p">:</span> <span class="mi">64</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt>From a prefix</dt>
<dd>Instead of specifying a pool, a prefix which will be searched
for new prefixes can be specified. In <cite>args</cite>, the key
<tt class="xref py py-attr docutils literal"><span class="pre">from-prefix</span></tt> is set to the prefix you want to allocate
from and the key <tt class="xref py py-attr docutils literal"><span class="pre">prefix_length</span></tt> is set to the wanted prefix
length.</dd>
</dl>
<p>Example:</p>
<div class="highlight-python"><pre>args = {
    'from-prefix': '192.0.2.0/24'
    'prefix_length': 27
}</pre>
</div>
<p>The key <tt class="xref py py-attr docutils literal"><span class="pre">count</span></tt> can also be set in the <cite>args</cite> argument to specify
how many prefixes that should be returned. If omitted, the default
value is 1000.</p>
<p>The <a class="reference internal" href="#nipap.nipap.Nipap.find_free_prefix" title="nipap.nipap.Nipap.find_free_prefix"><tt class="xref py py-func docutils literal"><span class="pre">find_free_prefix()</span></tt></a> function is used internally by the
<a class="reference internal" href="#nipap.nipap.Nipap.add_prefix" title="nipap.nipap.Nipap.add_prefix"><tt class="xref py py-func docutils literal"><span class="pre">add_prefix()</span></tt></a> function to find available prefixes from the given
sources.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.list_pool">
<tt class="descname">list_pool</tt><big>(</big><em>auth</em>, <em>schema_spec</em>, <em>spec={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.list_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of pools.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>schema_spec</cite> [schema_spec]</dt>
<dd><p class="first last">Specifies what schema we are working within.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [pool_spec]</dt>
<dd><p class="first last">Specifies what pool(s) to list. Of omitted, all will be listed.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.list_prefix">
<tt class="descname">list_prefix</tt><big>(</big><em>auth</em>, <em>schema_spec</em>, <em>spec=None</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.list_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>List prefixes matching the <cite>spec</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>schema_spec</cite> [schema_spec]</dt>
<dd><p class="first last">Specifies what schema we are working within.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [prefix_spec]</dt>
<dd><p class="first last">Specifies prefixes to list. If omitted, all will be listed.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
<p>This is a quite blunt tool for finding prefixes, mostly useful for
fetching data about a single prefix. For more capable alternatives,
see the <a class="reference internal" href="#nipap.nipap.Nipap.search_prefix" title="nipap.nipap.Nipap.search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">search_prefix()</span></tt></a> or <a class="reference internal" href="#nipap.nipap.Nipap.smart_search_prefix" title="nipap.nipap.Nipap.smart_search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">smart_search_prefix()</span></tt></a> functions.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.list_schema">
<tt class="descname">list_schema</tt><big>(</big><em>auth</em>, <em>spec={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.list_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of schemas matching <cite>spec</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [schema_spec]</dt>
<dd><p class="first last">A schema specification. If omitted, all schemas are returned.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.remove_pool">
<tt class="descname">remove_pool</tt><big>(</big><em>auth</em>, <em>schema_spec</em>, <em>spec</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.remove_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a pool.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>schema_spec</cite> [schema_spec]</dt>
<dd><p class="first last">Specifies what schema we are working within.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [pool_spec]</dt>
<dd><p class="first last">Specifies what pool(s) to remove.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.remove_prefix">
<tt class="descname">remove_prefix</tt><big>(</big><em>auth</em>, <em>schema_spec</em>, <em>spec</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.remove_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove prefix matching <cite>spec</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>schema_spec</cite> [schema_spec]</dt>
<dd><p class="first last">Specifies what schema we are working within.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [prefix_spec]</dt>
<dd><p class="first last">Specifies prefixe to remove.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.remove_schema">
<tt class="descname">remove_schema</tt><big>(</big><em>auth</em>, <em>spec</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.remove_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a schema.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [schema_spec]</dt>
<dd><p class="first last">A schema specification.</p>
</dd>
</dl>
</li>
</ul>
<p>Remove schema matching the <cite>spec</cite> argument.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.search_pool">
<tt class="descname">search_pool</tt><big>(</big><em>auth</em>, <em>schema_spec</em>, <em>query</em>, <em>search_options={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.search_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Search pool list for pools matching <cite>query</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>schema_spec</cite> [schema_spec]</dt>
<dd><p class="first last">Specifies what schema we are working within.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query</cite> [dict_to_sql]</dt>
<dd><p class="first last">How the search should be performed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options, see below.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
<p>The <cite>query</cite> argument passed to this function is designed to be
able to specify how quite advanced search operations should be
performed in a generic format. It is internally expanded to a SQL
WHERE-clause.</p>
<p>The <cite>query</cite> is a dict with three elements, where one specifies the
operation to perform and the two other specifies its arguments. The
arguments can themselves be <cite>query</cite> dicts, to build more complex
queries.</p>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">operator</span></tt> key specifies what operator should be used for the
comparison. Currently the following operators are supported:</p>
<ul class="simple">
<li><tt class="xref py py-data docutils literal"><span class="pre">and</span></tt> - Logical AND</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">or</span></tt> - Logical OR</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">equals</span></tt> - Equality; =</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">not_equals</span></tt> - Inequality; !=</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">like</span></tt> - SQL LIKE</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_match</span></tt> - Regular expression match</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_not_match</span></tt> - Regular expression not match</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> keys specifies the values which are subjected
to the comparison. <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> can be either any pool attribute or an
entire query dict. <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> can be either the value you want to
compare the pool attribute to, or an entire <cite>query</cite> dict.</p>
<p>Example 1 - Find the pool whose name match &#8216;test&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;equals&#39;</span><span class="p">,</span>
    <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;name&#39;</span><span class="p">,</span>
    <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;test&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will be expanded to the pseudo-SQL query:</p>
<div class="highlight-python"><pre>SELECT * FROM pool WHERE name = 'test'</pre>
</div>
<p>Example 2 - Find pools whose name or description regex matches &#8216;test&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;or&#39;</span><span class="p">,</span>
    <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;regex_match&#39;</span><span class="p">,</span>
        <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;name&#39;</span><span class="p">,</span>
        <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;test&#39;</span>
    <span class="p">},</span>
    <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;regex_match&#39;</span><span class="p">,</span>
        <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;description&#39;</span><span class="p">,</span>
        <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;test&#39;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will be expanded to the pseudo-SQL query:</p>
<div class="highlight-python"><pre>SELECT * FROM pool WHERE name ~* 'test' OR description ~* 'test'</pre>
</div>
<p>The search options can also be used to limit the number of rows
returned or set an offset for the result.</p>
<dl class="docutils">
<dt>The following options are available:</dt>
<dd><ul class="first last simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">max_result</span></tt> - The maximum number of pools to return (default <tt class="xref py py-data docutils literal"><span class="pre">50</span></tt>).</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">offset</span></tt> - Offset the result list this many pools (default <tt class="xref py py-data docutils literal"><span class="pre">0</span></tt>).</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.search_prefix">
<tt class="descname">search_prefix</tt><big>(</big><em>auth</em>, <em>schema_spec</em>, <em>query</em>, <em>search_options={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.search_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Search prefix list for prefixes matching <cite>query</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>schema_spec</cite> [schema_spec]</dt>
<dd><p class="first last">Specifies what schema we are working within.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query</cite> [dict_to_sql]</dt>
<dd><p class="first last">How the search should be performed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options, see below.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
<p>The <cite>query</cite> argument passed to this function is designed to be
able to specify how quite advanced search operations should be
performed in a generic format. It is internally expanded to a SQL
WHERE-clause.</p>
<p>The <cite>query</cite> is a dict with three elements, where one specifies the
operation to perform and the two other specifies its arguments. The
arguments can themselves be <cite>query</cite> dicts, to build more complex
queries.</p>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">operator</span></tt> key specifies what operator should be used for the
comparison. Currently the following operators are supported:</p>
<ul class="simple">
<li><tt class="xref py py-data docutils literal"><span class="pre">and</span></tt> - Logical AND</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">or</span></tt> - Logical OR</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">equals</span></tt> - Equality; =</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">not_equals</span></tt> - Inequality; !=</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">like</span></tt> - SQL LIKE</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_match</span></tt> - Regular expression match</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_not_match</span></tt> - Regular expression not match</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">contains</span></tt> - IP prefix contains</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">contains_equals</span></tt> - IP prefix contains or is equal to</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">contained_within</span></tt> - IP prefix is contained within</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">contained_within_equals</span></tt> - IP prefix is contained within or equals</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> keys specifies the values which are subjected
to the comparison. <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> can be either any prefix attribute or an
entire query dict. <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> can be either the value you want to
compare the prefix attribute to, or an entire <cite>query</cite> dict.</p>
<p>Example 1 - Find the prefixes which contains 192.0.2.0/24:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;contains&#39;</span><span class="p">,</span>
    <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;prefix&#39;</span><span class="p">,</span>
    <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;192.0.2.0/24&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will be expanded to the pseudo-SQL query:</p>
<div class="highlight-python"><pre>SELECT * FROM prefix WHERE prefix contains '192.0.2.0/24'</pre>
</div>
<p>Example 2 - Find for all assignments in prefix 192.0.2.0/24:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;and&#39;</span><span class="p">,</span>
    <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;equals&#39;</span><span class="p">,</span>
        <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;type&#39;</span><span class="p">,</span>
        <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;assignment&#39;</span>
    <span class="p">},</span>
    <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;contained_within&#39;</span><span class="p">,</span>
        <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;prefix&#39;</span><span class="p">,</span>
        <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;192.0.2.0/24&#39;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will be expanded to the pseudo-SQL query:</p>
<div class="highlight-python"><pre>SELECT * FROM prefix WHERE (type == 'assignment') AND (prefix contained within '192.0.2.0/24')</pre>
</div>
<p>The <cite>options</cite> argument provides a way to alter the search result a
bit to assist in client implementations. Most options regard parent
and children prefixes, that is the prefixes which contain the
prefix(es) matching the search terms (parents) or the prefixes
which are contained by the prefix(es) matching the search terms.
The search options can also be used to limit the number of rows
returned.</p>
<dl class="docutils">
<dt>The following options are available:</dt>
<dd><ul class="first last simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">parents_depth</span></tt> - How many levels of parents to return. Set to <tt class="xref py py-data docutils literal"><span class="pre">-1</span></tt> to include all parents.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">children_depth</span></tt> - How many levels of children to return. Set to <tt class="xref py py-data docutils literal"><span class="pre">-1</span></tt> to include all children.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">include_all_parents</span></tt> - Include all parents, no matter what depth is specified.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">include_all_children</span></tt> - Include all children, no matter what depth is specified.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">max_result</span></tt> - The maximum number of prefixes to return (default <tt class="xref py py-data docutils literal"><span class="pre">50</span></tt>).</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">offset</span></tt> - Offset the result list this many prefixes (default <tt class="xref py py-data docutils literal"><span class="pre">0</span></tt>).</li>
</ul>
</dd>
</dl>
<p>The options above gives the possibility to specify how many levels
of parent and child prefixes to return in addition to the prefixes
that actually matched the search terms. This is done by setting the
<tt class="xref py py-attr docutils literal"><span class="pre">parents_depth</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">children</span> <span class="pre">depth</span></tt> keys in the
<cite>search_options</cite> dict to an integer value.  In addition to this it
is possible to get all all parents and/or children included in the
result set even though they are outside the limits set with
<tt class="xref py py-attr docutils literal"><span class="pre">*_depth</span></tt>.  The extra prefixes included will have the
attribute <tt class="xref py py-attr docutils literal"><span class="pre">display</span></tt> set to <tt class="xref py py-data docutils literal"><span class="pre">false</span></tt> while the other ones
(the actual search result togther with the ones included due to
given depth) <tt class="xref py py-attr docutils literal"><span class="pre">display</span></tt> set to <tt class="xref py py-data docutils literal"><span class="pre">true</span></tt>. This feature is
usable obtain search results with some context given around them,
useful for example when displaying prefixes in a tree without the
need to implement client side IP address logic.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.search_schema">
<tt class="descname">search_schema</tt><big>(</big><em>auth</em>, <em>query</em>, <em>search_options={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.search_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Search schema list for schemas matching <cite>query</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query</cite> [dict_to_sql]</dt>
<dd><p class="first last">How the search should be performed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options, see below.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
<p>The <cite>query</cite> argument passed to this function is designed to be
able to specify how quite advanced search operations should be
performed in a generic format. It is internally expanded to a SQL
WHERE-clause.</p>
<p>The <cite>query</cite> is a dict with three elements, where one specifies the
operation to perform and the two other specifies its arguments. The
arguments can themselves be <cite>query</cite> dicts, to build more complex
queries.</p>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">operator</span></tt> key specifies what operator should be used for the
comparison. Currently the following operators are supported:</p>
<ul class="simple">
<li><tt class="xref py py-data docutils literal"><span class="pre">and</span></tt> - Logical AND</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">or</span></tt> - Logical OR</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">equals</span></tt> - Equality; =</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">not_equals</span></tt> - Inequality; !=</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">like</span></tt> - SQL LIKE</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_match</span></tt> - Regular expression match</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_not_match</span></tt> - Regular expression not match</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> keys specifies the values which are subjected
to the comparison. <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> can be either any prefix attribute or an
entire query dict. <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> can be either the value you want to
compare the prefix attribute to, or an entire <cite>query</cite> dict.</p>
<p>Example 1 - Find the schema whose name match &#8216;test&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;equals&#39;</span><span class="p">,</span>
    <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;name&#39;</span><span class="p">,</span>
    <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;test&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will be expanded to the pseudo-SQL query:</p>
<div class="highlight-python"><pre>SELECT * FROM schema WHERE name = 'test'</pre>
</div>
<p>Example 2 - Find schema whose name or description regex matches &#8216;test&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;or&#39;</span><span class="p">,</span>
    <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;regex_match&#39;</span><span class="p">,</span>
        <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;name&#39;</span><span class="p">,</span>
        <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;test&#39;</span>
    <span class="p">},</span>
    <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;regex_match&#39;</span><span class="p">,</span>
        <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;description&#39;</span><span class="p">,</span>
        <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;test&#39;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will be expanded to the pseudo-SQL query:</p>
<div class="highlight-python"><pre>SELECT * FROM schema WHERE name ~* 'test' OR description ~* 'test'</pre>
</div>
<p>The search options can also be used to limit the number of rows
returned or set an offset for the result.</p>
<dl class="docutils">
<dt>The following options are available:</dt>
<dd><ul class="first last simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">max_result</span></tt> - The maximum number of prefixes to return (default <tt class="xref py py-data docutils literal"><span class="pre">50</span></tt>).</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">offset</span></tt> - Offset the result list this many prefixes (default <tt class="xref py py-data docutils literal"><span class="pre">0</span></tt>).</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.smart_search_pool">
<tt class="descname">smart_search_pool</tt><big>(</big><em>auth</em>, <em>schema_spec</em>, <em>query_str</em>, <em>search_options={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.smart_search_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a smart search on pool list.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>schema_spec</cite> [schema_spec]</dt>
<dd><p class="first last">Specifies what schema we are working within.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query_str</cite> [string]</dt>
<dd><p class="first last">Search string</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options. See <a class="reference internal" href="#nipap.nipap.Nipap.search_pool" title="nipap.nipap.Nipap.search_pool"><tt class="xref py py-func docutils literal"><span class="pre">search_pool()</span></tt></a>.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Return a dict with three elements:</dt>
<dd><ul class="first simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> - How the query string was interpreted.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">search_options</span></tt> - Various search_options.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> - The search result.</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> is given as a list of dicts, each
explaining how a part of the search key was interpreted (ie. what
pool attribute the search operation was performed on).</p>
<p class="last">The <tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> is a list of dicts containing the search result.</p>
</dd>
</dl>
<p>The smart search function tries to convert the query from a text
string to a <cite>query</cite> dict which is passed to the
<a class="reference internal" href="#nipap.nipap.Nipap.search_pool" title="nipap.nipap.Nipap.search_pool"><tt class="xref py py-func docutils literal"><span class="pre">search_pool()</span></tt></a> function.  If multiple search keys are
detected, they are combined with a logical AND.</p>
<p>It will basically just take each search term and try to match it
against the name or description column with regex match.</p>
<p>See the <a class="reference internal" href="#nipap.nipap.Nipap.search_pool" title="nipap.nipap.Nipap.search_pool"><tt class="xref py py-func docutils literal"><span class="pre">search_pool()</span></tt></a> function for an explanation of the
<cite>search_options</cite> argument.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.smart_search_prefix">
<tt class="descname">smart_search_prefix</tt><big>(</big><em>auth</em>, <em>schema_spec</em>, <em>query_str</em>, <em>search_options={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.smart_search_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a smart search on prefix list.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>schema_spec</cite> [schema_spec]</dt>
<dd><p class="first last">Specifies what schema we are working within.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query_str</cite> [string]</dt>
<dd><p class="first last">Search string</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options. See <a class="reference internal" href="#nipap.nipap.Nipap.search_prefix" title="nipap.nipap.Nipap.search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">search_prefix()</span></tt></a>.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Return a dict with three elements:</dt>
<dd><ul class="first simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> - How the query string was interpreted.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">search_options</span></tt> - Various search_options.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> - The search result.</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> is given as a list of dicts, each
explaining how a part of the search key was interpreted (ie. what
prefix attribute the search operation was performed on).</p>
<p class="last">The <tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> is a list of dicts containing the search result.</p>
</dd>
</dl>
<p>The smart search function tries to convert the query from a text
string to a <cite>query</cite> dict which is passed to the
<a class="reference internal" href="#nipap.nipap.Nipap.search_prefix" title="nipap.nipap.Nipap.search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">search_prefix()</span></tt></a> function.  If multiple search keys are
detected, they are combined with a logical AND.</p>
<p>It tries to automatically detect IP addresses and prefixes and put
these into the <cite>query</cite> dict with &#8220;contains_within&#8221; operators and so
forth.</p>
<p>See the <a class="reference internal" href="#nipap.nipap.Nipap.search_prefix" title="nipap.nipap.Nipap.search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">search_prefix()</span></tt></a> function for an explanation of the
<cite>search_options</cite> argument.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.smart_search_schema">
<tt class="descname">smart_search_schema</tt><big>(</big><em>auth</em>, <em>query_str</em>, <em>search_options={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.smart_search_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a smart search on schema list.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query_str</cite> [string]</dt>
<dd><p class="first last">Search string</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options. See <a class="reference internal" href="#nipap.nipap.Nipap.search_schema" title="nipap.nipap.Nipap.search_schema"><tt class="xref py py-func docutils literal"><span class="pre">search_schema()</span></tt></a>.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Return a dict with three elements:</dt>
<dd><ul class="first simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> - How the query string was interpreted.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">search_options</span></tt> - Various search_options.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> - The search result.</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> is given as a list of dicts, each
explaining how a part of the search key was interpreted (ie. what
schema attribute the search operation was performed on).</p>
<p class="last">The <tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> is a list of dicts containing the search result.</p>
</dd>
</dl>
<p>The smart search function tries to convert the query from a text
string to a <cite>query</cite> dict which is passed to the
<a class="reference internal" href="#nipap.nipap.Nipap.search_schema" title="nipap.nipap.Nipap.search_schema"><tt class="xref py py-func docutils literal"><span class="pre">search_schema()</span></tt></a> function.  If multiple search keys are
detected, they are combined with a logical AND.</p>
<p>It will basically just take each search term and try to match it
against the name or description column with regex match or the VRF
column with an exact match.</p>
<p>See the <a class="reference internal" href="#nipap.nipap.Nipap.search_schema" title="nipap.nipap.Nipap.search_schema"><tt class="xref py py-func docutils literal"><span class="pre">search_schema()</span></tt></a> function for an explanation of the
<cite>search_options</cite> argument.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapDuplicateError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapDuplicateError</tt><a class="headerlink" href="#nipap.nipap.NipapDuplicateError" title="Permalink to this definition">¶</a></dt>
<dd><p>The passed object violates unique constraints</p>
<p>For example, create a schema with a name of an already existing one.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapError</tt><a class="headerlink" href="#nipap.nipap.NipapError" title="Permalink to this definition">¶</a></dt>
<dd><p>NIPAP base error class.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapExtraneousInputError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapExtraneousInputError</tt><a class="headerlink" href="#nipap.nipap.NipapExtraneousInputError" title="Permalink to this definition">¶</a></dt>
<dd><p>Extraneous input.</p>
<p>Most input is passed in dicts, this could mean an unknown key in a dict.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapInputError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapInputError</tt><a class="headerlink" href="#nipap.nipap.NipapInputError" title="Permalink to this definition">¶</a></dt>
<dd><p>Erroneous input.</p>
<p>A general input error.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapMissingInputError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapMissingInputError</tt><a class="headerlink" href="#nipap.nipap.NipapMissingInputError" title="Permalink to this definition">¶</a></dt>
<dd><p>Missing input.</p>
<p>Most input is passed in dicts, this could mean a missing key in a dict.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapNoSuchOperatorError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapNoSuchOperatorError</tt><a class="headerlink" href="#nipap.nipap.NipapNoSuchOperatorError" title="Permalink to this definition">¶</a></dt>
<dd><p>A non existent operator was specified.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapNonExistentError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapNonExistentError</tt><a class="headerlink" href="#nipap.nipap.NipapNonExistentError" title="Permalink to this definition">¶</a></dt>
<dd><p>A non existent object was specified</p>
<p>For example, try to get a prefix from a pool which doesn&#8217;t exist.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapValueError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapValueError</tt><a class="headerlink" href="#nipap.nipap.NipapValueError" title="Permalink to this definition">¶</a></dt>
<dd><p>Something wrong with a value</p>
<p>For example, trying to send an integer when an IP address is expected.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">NIPAP API</a><ul>
<li><a class="reference internal" href="#schema">Schema</a><ul>
<li><a class="reference internal" href="#schema-attributes">Schema attributes</a></li>
<li><a class="reference internal" href="#schema-functions">Schema functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#prefix">Prefix</a><ul>
<li><a class="reference internal" href="#prefix-attributes">Prefix attributes</a></li>
<li><a class="reference internal" href="#prefix-functions">Prefix functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pool">Pool</a><ul>
<li><a class="reference internal" href="#pool-attributes">Pool attributes</a></li>
<li><a class="reference internal" href="#pool-functions">Pool functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-spec">The &#8216;spec&#8217;</a></li>
<li><a class="reference internal" href="#authorization-accounting">Authorization &amp; accounting</a></li>
<li><a class="reference internal" href="#classes">Classes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="design.html"
                        title="previous chapter">Design choices</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="xmlrpc.html"
                        title="next chapter">XML-RPC glue class</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="xmlrpc.html" title="XML-RPC glue class"
             >next</a> |</li>
        <li class="right" >
          <a href="design.html" title="Design choices"
             >previous</a> |</li>
        <li><a href="index.html">NIPAP v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Kristian Larsson &lt;kll@tele2.net&gt;, Lukas Garberg &lt;lukas@tele2.net&gt;.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>